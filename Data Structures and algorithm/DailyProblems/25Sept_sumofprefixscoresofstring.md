# Sum of Prefix Scores of Strings
[Problem Link](https://leetcode.com/problems/sum-of-prefix-scores-of-strings/description/?envType=daily-question&envId=2024-09-25)

## Problem desciption 
You are given an array words of size n consisting of non-empty strings.

We define the score of a string word as the number of strings words[i] such that word is a prefix of words[i].

For example, if words = ["a", "ab", "abc", "cab"], then the score of "ab" is 2, since "ab" is a prefix of both "ab" and "abc".
Return an array answer of size n where answer[i] is the sum of scores of every non-empty prefix of words[i].

Note that a string is considered as a prefix of itself.

### Example 1:

> **Input:** words = ["abc","ab","bc","b"]<br>
> **Output:** [5,4,3,2]<br>
> **Explanation:** The answer for each string is the > following:<br>
> - "abc" has 3 prefixes: "a", "ab", and "abc".<br>
> - There are 2 strings with the prefix "a", 2 strings with the > prefix "ab", and 1 string with the prefix "abc".<br>
> The total is answer[0] = 2 + 2 + 1 = 5.
> - "ab" has 2 prefixes: "a" and "ab".<br>
> - There are 2 strings with the prefix "a", and 2 strings with > the prefix "ab".<br>
> The total is answer[1] = 2 + 2 = 4.
> - "bc" has 2 prefixes: "b" and "bc".<br>
> - There are 2 strings with the prefix "b", and 1 string with > the prefix "bc".<br>
> The total is answer[2] = 2 + 1 = 3.<br>
> - "b" has 1 prefix: "b".<br>
> - There are 2 strings with the prefix "b".<br>
> The total is answer[3] = 2.<br>

## constraints
* 1 <= words.length <= 1000
* 1 <= words[i].length <= 1000
* words[i] consists of lowercase English letters.

## Code
```cpp
struct TrieNode {
    int cnt;
    TrieNode* children[26];
};
class Solution {
public:
    TrieNode* getNewNode(){
        TrieNode* node = new TrieNode();
        
        for(int i = 0;i<26;i++){
            node->cnt = 0;
            node->children[i] = nullptr;
        }
        return node;
    }

    void insert(string word, TrieNode* root) {
        TrieNode* crawl = root;

        for(char ch: word){
            int idx = ch-'a';
            if(crawl->children[idx]==nullptr){
                crawl->children[idx] = getNewNode();
            }
            crawl->children[idx]->cnt++;
            crawl = crawl->children[idx];
        }
    }

    int search(string word, TrieNode* root) {
        int val = 0;
        TrieNode* crawl = root;
        for(char ch: word){
            int idx = ch-'a';
            if(crawl->children[idx] != nullptr ){
                val += crawl->children[idx]->cnt;
                crawl = crawl->children[idx];
            }else break;
        }
        return val;
    }

    vector<int> sumPrefixScores(vector<string>& words) {

        TrieNode* root = getNewNode();

        //create prefix tree 
        for(string s: words){
            insert(s,root);
        }

        vector<int> vec;
        for(string s: words){
            vec.push_back(search(s,root));
        }
        return vec;
    }
};
```

## Intuition
The intution is to keep track of the number of same prefix generated by scanning all the strings given. Next we iterate again through the strings and keep adding that too the current string value and return it.
The idea to use the Trie comes from the question itself - Prefix of strings, by effectively leveraging Fields of tries tha includes count variable which keeps track of the number of prefix generated of the same kind.


## Complexity
- Time complexity: O(N*K)


- Space complexity: O(N*K)
